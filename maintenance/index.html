<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Failure Prediction System</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        /* Previous CSS styles remain the same, adding new styles for ROC curve */
        
        .roc-curve-container {
            height: 400px;
            margin-top: 20px;
        }
        
        .threshold-control {
            margin: 20px 0;
            padding: 15px;
            background: var(--light);
            border-radius: 5px;
        }
        
        .threshold-slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .threshold-value {
            font-weight: bold;
            color: var(--secondary);
        }
        
        .imbalance-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .sampling-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 15px 0;
        }
        
        .sampling-option {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .sampling-option:hover {
            border-color: var(--secondary);
        }
        
        .sampling-option.selected {
            border-color: var(--success);
            background: rgba(46, 204, 113, 0.1);
        }
        
        .feature-importance-chart {
            height: 400px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Machine Failure Prediction System</h1>
            <p class="subtitle">Complete ML Pipeline with Class Imbalance Handling</p>
        </header>
        
        <div class="ml-pipeline">
            <h2>Machine Learning Pipeline</h2>
            <div class="pipeline-steps">
                <div class="pipeline-step step-active" id="step1">
                    <div class="step-number">1</div>
                    <h3>Data Upload</h3>
                    <p>Upload your CSV dataset</p>
                    <div class="status-badge status-pending">Pending</div>
                </div>
                <div class="pipeline-step" id="step2">
                    <div class="step-number">2</div>
                    <h3>Dataset Info</h3>
                    <p>Explore dataset characteristics</p>
                    <div class="status-badge status-pending">Pending</div>
                </div>
                <div class="pipeline-step" id="step3">
                    <div class="step-number">3</div>
                    <h3>EDA</h3>
                    <p>Exploratory Data Analysis</p>
                    <div class="status-badge status-pending">Pending</div>
                </div>
                <div class="pipeline-step" id="step4">
                    <div class="step-number">4</div>
                    <h3>Preprocessing</h3>
                    <p>Handle class imbalance & prepare data</p>
                    <div class="status-badge status-pending">Pending</div>
                </div>
                <div class="pipeline-step" id="step5">
                    <div class="step-number">5</div>
                    <h3>Model Training</h3>
                    <p>Train neural network</p>
                    <div class="status-badge status-pending">Pending</div>
                </div>
                <div class="pipeline-step" id="step6">
                    <div class="step-number">6</div>
                    <h3>Evaluation</h3>
                    <p>Test model performance</p>
                    <div class="status-badge status-pending">Pending</div>
                </div>
            </div>
            
            <div class="card">
                <div class="tabs">
                    <div class="tab active" data-tab="data-upload">Data Upload</div>
                    <div class="tab" data-tab="dataset-info">Dataset Info</div>
                    <div class="tab" data-tab="eda">EDA</div>
                    <div class="tab" data-tab="preprocessing">Preprocessing</div>
                    <div class="tab" data-tab="training">Model Training</div>
                    <div class="tab" data-tab="evaluation">Evaluation</div>
                </div>
                
                <!-- Previous tab contents remain the same until preprocessing -->
                
                <div class="tab-content" id="preprocessing">
                    <h3>Data Preprocessing & Class Imbalance Handling</h3>
                    <div id="preprocessing-content">
                        <p>Please complete EDA first to preprocess data</p>
                    </div>
                    
                    <div id="class-imbalance-section" style="display: none;">
                        <!-- Class imbalance handling will be populated here -->
                    </div>
                    
                    <div id="data-split-info" style="display: none;">
                        <!-- Data split info will be populated here -->
                    </div>
                    
                    <div id="preprocessed-preview" style="display: none;">
                        <h4>Preprocessed Data Preview (First 10 rows of training set)</h4>
                        <div class="preview-table">
                            <table id="preprocessed-table">
                                <thead id="preprocessed-table-head">
                                    <!-- Headers will be populated by JavaScript -->
                                </thead>
                                <tbody id="preprocessed-table-body">
                                    <!-- Data will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <button class="btn btn-warning" id="train-btn" style="margin-top: 15px; display: none;">Train Model</button>
                </div>
                
                <div class="tab-content" id="evaluation">
                    <h3>Model Evaluation</h3>
                    <div id="evaluation-content">
                        <p>Please train the model first to see evaluation results</p>
                    </div>
                    
                    <div id="roc-curve-section" style="display: none;">
                        <h3>ROC Curve & Threshold Optimization</h3>
                        <div class="roc-curve-container">
                            <canvas id="roc-curve"></canvas>
                        </div>
                        <div class="threshold-control">
                            <label>Classification Threshold: <span class="threshold-value" id="threshold-value">0.5</span></label>
                            <input type="range" min="0" max="1" step="0.01" value="0.5" class="threshold-slider" id="threshold-slider">
                            <p><small>Adjust the threshold to balance precision and recall. Lower thresholds increase recall (catch more failures).</small></p>
                        </div>
                    </div>
                    
                    <div id="feature-importance-section" style="display: none; margin-top: 30px;">
                        <h3>Feature Importance</h3>
                        <div class="feature-importance-chart">
                            <canvas id="feature-importance-chart"></canvas>
                        </div>
                    </div>
                    
                    <button class="btn btn-success" id="prediction-ready-btn" style="margin-top: 15px; display: none;">Ready for Predictions</button>
                </div>
            </div>
        </div>
        
        <!-- Rest of the HTML remains the same -->
        
    </div>

    <script>
        // Enhanced ML Pipeline with Class Imbalance Handling
        class MLPipeline {
            constructor() {
                this.csvParser = new FlexibleCSVParser();
                this.rawData = [];
                this.dataset = [];
                this.X_train = [];
                this.X_test = [];
                this.y_train = [];
                this.y_test = [];
                this.processedData = {
                    X_train_processed: [],
                    X_test_processed: [],
                    y_train: [],
                    y_test: []
                };
                this.model = null;
                this.featureImportance = [];
                this.modelMetrics = {
                    accuracy: 0,
                    precision: 0,
                    recall: 0,
                    f1: 0,
                    roc_auc: 0,
                    confusionMatrix: [0, 0, 0, 0]
                };
                this.rocCurve = { fpr: [], tpr: [], thresholds: [] };
                this.classImbalanceMethod = 'none';
                this.predictionThreshold = 0.5;
                // ... other properties remain the same
            }

            // ... previous methods remain the same until handleClassImbalance

            handleClassImbalance(method) {
                this.classImbalanceMethod = method;
                
                if (method === 'none') {
                    return; // No handling
                }
                
                // Separate features and target
                const X = this.dataset.map(record => ({
                    Type: record.Type,
                    AirTemp: record.AirTemp,
                    ProcessTemp: record.ProcessTemp,
                    RotationalSpeed: record.RotationalSpeed,
                    Torque: record.Torque,
                    ToolWear: record.ToolWear
                }));
                
                const y = this.dataset.map(record => record.Failure);
                
                if (method === 'smote') {
                    // Apply SMOTE-like oversampling
                    this.applySMOTE(X, y);
                } else if (method === 'undersampling') {
                    // Apply random undersampling
                    this.applyUndersampling(X, y);
                } else if (method === 'class_weight') {
                    // Class weights will be applied during training
                    return;
                }
            }

            applySMOTE(features, targets) {
                // Find minority class samples
                const minorityClass = 1;
                const minoritySamples = [];
                const majoritySamples = [];
                
                features.forEach((feature, index) => {
                    if (targets[index] === minorityClass) {
                        minoritySamples.push({ feature, target: targets[index] });
                    } else {
                        majoritySamples.push({ feature, target: targets[index] });
                    }
                });
                
                // Calculate how many synthetic samples to create
                const desiredRatio = 0.5; // Target 1:1 ratio
                const totalSamples = features.length;
                const desiredMinorityCount = Math.floor(totalSamples * desiredRatio);
                const samplesToCreate = desiredMinorityCount - minoritySamples.length;
                
                if (samplesToCreate <= 0) return;
                
                // Create synthetic samples
                const syntheticSamples = [];
                for (let i = 0; i < samplesToCreate; i++) {
                    // Randomly select a minority sample
                    const randomIndex = Math.floor(Math.random() * minoritySamples.length);
                    const sample = minoritySamples[randomIndex];
                    
                    // Find k nearest neighbors (simplified - just random selection)
                    const k = 5;
                    const neighbors = [];
                    for (let j = 0; j < k; j++) {
                        const neighborIndex = Math.floor(Math.random() * minoritySamples.length);
                        if (neighborIndex !== randomIndex) {
                            neighbors.push(minoritySamples[neighborIndex]);
                        }
                    }
                    
                    // Create synthetic sample
                    if (neighbors.length > 0) {
                        const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        const syntheticFeature = {};
                        
                        // Interpolate between sample and neighbor
                        Object.keys(sample.feature).forEach(key => {
                            const diff = randomNeighbor.feature[key] - sample.feature[key];
                            const gap = Math.random();
                            syntheticFeature[key] = sample.feature[key] + gap * diff;
                        });
                        
                        syntheticSamples.push({
                            feature: syntheticFeature,
                            target: minorityClass
                        });
                    }
                }
                
                // Combine original and synthetic samples
                const allSamples = [
                    ...minoritySamples,
                    ...syntheticSamples,
                    ...majoritySamples
                ];
                
                // Shuffle the dataset
                allSamples.sort(() => Math.random() - 0.5);
                
                // Update dataset
                this.dataset = allSamples.map(item => ({
                    Type: item.feature.Type,
                    AirTemp: item.feature.AirTemp,
                    ProcessTemp: item.feature.ProcessTemp,
                    RotationalSpeed: item.feature.RotationalSpeed,
                    Torque: item.feature.Torque,
                    ToolWear: item.feature.ToolWear,
                    Failure: item.target
                }));
            }

            applyUndersampling(features, targets) {
                // Separate classes
                const minorityClass = 1;
                const minoritySamples = [];
                const majoritySamples = [];
                
                features.forEach((feature, index) => {
                    if (targets[index] === minorityClass) {
                        minoritySamples.push({ feature, target: targets[index] });
                    } else {
                        majoritySamples.push({ feature, target: targets[index] });
                    }
                });
                
                // Randomly select majority samples to match minority count
                const undersampledMajority = [];
                const samplesToKeep = minoritySamples.length;
                
                for (let i = 0; i < samplesToKeep; i++) {
                    const randomIndex = Math.floor(Math.random() * majoritySamples.length);
                    undersampledMajority.push(majoritySamples[randomIndex]);
                    majoritySamples.splice(randomIndex, 1);
                }
                
                // Combine samples
                const allSamples = [
                    ...minoritySamples,
                    ...undersampledMajority
                ];
                
                // Shuffle the dataset
                allSamples.sort(() => Math.random() - 0.5);
                
                // Update dataset
                this.dataset = allSamples.map(item => ({
                    Type: item.feature.Type,
                    AirTemp: item.feature.AirTemp,
                    ProcessTemp: item.feature.ProcessTemp,
                    RotationalSpeed: item.feature.RotationalSpeed,
                    Torque: item.feature.Torque,
                    ToolWear: item.feature.ToolWear,
                    Failure: item.target
                }));
            }

            calculateClassWeights() {
                const failureCount = this.dataset.filter(d => d.Failure === 1).length;
                const nonFailureCount = this.dataset.filter(d => d.Failure === 0).length;
                const total = failureCount + nonFailureCount;
                
                // Higher weight for minority class (failures)
                const weightFailure = total / (2 * failureCount);
                const weightNonFailure = total / (2 * nonFailureCount);
                
                return {
                    0: weightNonFailure,
                    1: weightFailure
                };
            }

            trainModel() {
                const classWeights = this.classImbalanceMethod === 'class_weight' ? 
                    this.calculateClassWeights() : { 0: 1, 1: 1 };
                
                // Enhanced neural network with class weights
                const inputSize = this.processedData.X_train_processed[0].length;
                const hiddenSize = 16; // Increased hidden size
                const outputSize = 1;
                
                // Initialize weights with better initialization
                const weights1 = Array(inputSize).fill().map(() => 
                    Array(hiddenSize).fill().map(() => (Math.random() - 0.5) * Math.sqrt(2 / inputSize))
                );
                const weights2 = Array(hiddenSize).fill().map(() => 
                    Array(outputSize).fill().map(() => (Math.random() - 0.5) * Math.sqrt(2 / hiddenSize))
                );
                
                const biases1 = Array(hiddenSize).fill(0);
                const biases2 = Array(outputSize).fill(0);
                
                // Training parameters
                const learningRate = 0.01;
                const epochs = 200; // Increased epochs
                
                // Training loop with class weights
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalLoss = 0;
                    
                    for (let i = 0; i < this.processedData.X_train_processed.length; i++) {
                        const input = this.processedData.X_train_processed[i];
                        const target = this.processedData.y_train[i];
                        const weight = classWeights[target];
                        
                        // Forward pass
                        const hidden = Array(hiddenSize).fill(0);
                        for (let j = 0; j < hiddenSize; j++) {
                            let sum = biases1[j];
                            for (let k = 0; k < inputSize; k++) {
                                sum += input[k] * weights1[k][j];
                            }
                            hidden[j] = Math.max(0, sum); // ReLU activation
                        }
                        
                        const output = Array(outputSize).fill(0);
                        for (let j = 0; j < outputSize; j++) {
                            let sum = biases2[j];
                            for (let k = 0; k < hiddenSize; k++) {
                                sum += hidden[k] * weights2[k][j];
                            }
                            output[j] = 1 / (1 + Math.exp(-sum)); // Sigmoid activation
                        }
                        
                        // Calculate weighted loss
                        const loss = -weight * (target * Math.log(output[0]) + (1 - target) * Math.log(1 - output[0]));
                        totalLoss += loss;
                        
                        // Backward pass
                        const outputError = (output[0] - target) * weight;
                        
                        // Update weights and biases for output layer
                        for (let j = 0; j < hiddenSize; j++) {
                            for (let k = 0; k < outputSize; k++) {
                                weights2[j][k] -= learningRate * outputError * hidden[j];
                            }
                        }
                        for (let j = 0; j < outputSize; j++) {
                            biases2[j] -= learningRate * outputError;
                        }
                        
                        // Calculate hidden layer errors
                        const hiddenErrors = Array(hiddenSize).fill(0);
                        for (let j = 0; j < hiddenSize; j++) {
                            let error = 0;
                            for (let k = 0; k < outputSize; k++) {
                                error += outputError * weights2[j][k];
                            }
                            hiddenErrors[j] = error * (hidden[j] > 0 ? 1 : 0); // ReLU derivative
                        }
                        
                        // Update weights and biases for hidden layer
                        for (let j = 0; j < inputSize; j++) {
                            for (let k = 0; k < hiddenSize; k++) {
                                weights1[j][k] -= learningRate * hiddenErrors[k] * input[j];
                            }
                        }
                        for (let j = 0; j < hiddenSize; j++) {
                            biases1[j] -= learningRate * hiddenErrors[j];
                        }
                    }
                }
                
                // Store the trained model
                this.model = {
                    weights1,
                    weights2,
                    biases1,
                    biases2,
                    inputSize,
                    hiddenSize,
                    outputSize
                };
                
                // Calculate feature importance
                this.calculateFeatureImportance();
                
                return this.model;
            }

            calculateFeatureImportance() {
                const { weights1 } = this.model;
                
                // Calculate feature importance based on weight magnitudes
                this.featureImportance = Array(weights1.length).fill(0);
                for (let i = 0; i < weights1.length; i++) {
                    for (let j = 0; j < weights1[i].length; j++) {
                        this.featureImportance[i] += Math.abs(weights1[i][j]);
                    }
                }
                
                // Normalize to percentages
                const total = this.featureImportance.reduce((sum, val) => sum + val, 0);
                this.featureImportance = this.featureImportance.map(val => (val / total) * 100);
                
                return this.featureImportance;
            }

            calculateROCCurve() {
                const { weights1, weights2, biases1, biases2, hiddenSize, outputSize } = this.model;
                const probabilities = [];
                const actuals = [];
                
                // Get probabilities for test set
                for (let i = 0; i < this.processedData.X_test_processed.length; i++) {
                    const input = this.processedData.X_test_processed[i];
                    const target = this.processedData.y_test[i];
                    
                    // Forward pass
                    const hidden = Array(hiddenSize).fill(0);
                    for (let j = 0; j < hiddenSize; j++) {
                        let sum = biases1[j];
                        for (let k = 0; k < input.length; k++) {
                            sum += input[k] * weights1[k][j];
                        }
                        hidden[j] = Math.max(0, sum);
                    }
                    
                    const output = Array(outputSize).fill(0);
                    for (let j = 0; j < outputSize; j++) {
                        let sum = biases2[j];
                        for (let k = 0; k < hiddenSize; k++) {
                            sum += hidden[k] * weights2[k][j];
                        }
                        output[j] = 1 / (1 + Math.exp(-sum));
                    }
                    
                    probabilities.push(output[0]);
                    actuals.push(target);
                }
                
                // Calculate ROC curve points
                const thresholds = Array.from({ length: 101 }, (_, i) => i / 100);
                const fpr = [];
                const tpr = [];
                
                thresholds.forEach(threshold => {
                    let truePositives = 0;
                    let falsePositives = 0;
                    let trueNegatives = 0;
                    let falseNegatives = 0;
                    
                    for (let i = 0; i < probabilities.length; i++) {
                        const prediction = probabilities[i] >= threshold ? 1 : 0;
                        const actual = actuals[i];
                        
                        if (prediction === 1 && actual === 1) truePositives++;
                        else if (prediction === 1 && actual === 0) falsePositives++;
                        else if (prediction === 0 && actual === 1) falseNegatives++;
                        else if (prediction === 0 && actual === 0) trueNegatives++;
                    }
                    
                    const tprate = truePositives / (truePositives + falseNegatives) || 0;
                    const fprate = falsePositives / (falsePositives + trueNegatives) || 0;
                    
                    tpr.push(tprate);
                    fpr.push(fprate);
                });
                
                // Calculate AUC (Area Under Curve)
                let auc = 0;
                for (let i = 1; i < fpr.length; i++) {
                    auc += (fpr[i] - fpr[i-1]) * (tpr[i] + tpr[i-1]) / 2;
                }
                
                this.rocCurve = {
                    fpr,
                    tpr,
                    thresholds,
                    auc
                };
                
                return this.rocCurve;
            }

            evaluateModel(threshold = 0.5) {
                this.predictionThreshold = threshold;
                
                if (!this.model) {
                    throw new Error("Model not trained yet");
                }
                
                const { weights1, weights2, biases1, biases2, hiddenSize, outputSize } = this.model;
                
                // Test on test set
                let testCorrect = 0;
                let truePositives = 0, falsePositives = 0, trueNegatives = 0, falseNegatives = 0;
                const probabilities = [];
                
                for (let i = 0; i < this.processedData.X_test_processed.length; i++) {
                    const input = this.processedData.X_test_processed[i];
                    const target = this.processedData.y_test[i];
                    
                    // Forward pass
                    const hidden = Array(hiddenSize).fill(0);
                    for (let j = 0; j < hiddenSize; j++) {
                        let sum = biases1[j];
                        for (let k = 0; k < input.length; k++) {
                            sum += input[k] * weights1[k][j];
                        }
                        hidden[j] = Math.max(0, sum);
                    }
                    
                    const output = Array(outputSize).fill(0);
                    for (let j = 0; j < outputSize; j++) {
                        let sum = biases2[j];
                        for (let k = 0; k < hiddenSize; k++) {
                            sum += hidden[k] * weights2[k][j];
                        }
                        output[j] = 1 / (1 + Math.exp(-sum));
                    }
                    
                    const probability = output[0];
                    probabilities.push(probability);
                    const prediction = probability >= threshold ? 1 : 0;
                    
                    if (prediction === target) {
                        testCorrect++;
                        if (prediction === 1) {
                            truePositives++;
                        } else {
                            trueNegatives++;
                        }
                    } else {
                        if (prediction === 1) {
                            falsePositives++;
                        } else {
                            falseNegatives++;
                        }
                    }
                }
                
                const testAccuracy = testCorrect / this.processedData.X_test_processed.length;
                
                // Calculate additional metrics
                const precision = truePositives / (truePositives + falsePositives) || 0;
                const recall = truePositives / (truePositives + falseNegatives) || 0;
                const f1 = 2 * (precision * recall) / (precision + recall) || 0;
                
                // Calculate ROC AUC
                this.calculateROCCurve();
                const roc_auc = this.rocCurve.auc;
                
                this.modelMetrics = {
                    accuracy: testAccuracy,
                    precision,
                    recall,
                    f1,
                    roc_auc,
                    confusionMatrix: [truePositives, falsePositives, falseNegatives, trueNegatives],
                    probabilities
                };
                
                return this.modelMetrics;
            }

            // ... rest of the methods remain the same
        }

        // Enhanced UI Controller with Class Imbalance Handling
        class UIController {
            // ... previous methods remain the same until preprocessData

            preprocessData() {
                this.showLoading('Preprocessing data...');
                
                // Switch to preprocessing tab
                this.switchTab('preprocessing');
                
                setTimeout(() => {
                    // Display class imbalance information
                    this.displayClassImbalanceInfo();
                    
                    this.hideLoading();
                }, 500);
            }

            displayClassImbalanceInfo() {
                const failureCount = this.pipeline.dataset.filter(record => record.Failure === 1).length;
                const nonFailureCount = this.pipeline.dataset.filter(record => record.Failure === 0).length;
                const total = failureCount + nonFailureCount;
                const failureRate = ((failureCount / total) * 100).toFixed(1);
                
                const section = document.getElementById('class-imbalance-section');
                let html = '<div class="imbalance-notice">';
                html += `<h4>Class Imbalance Detected</h4>`;
                html += `<p><strong>Failure Rate:</strong> ${failureRate}% (${failureCount} failures out of ${total} records)</p>`;
                html += `<p><strong>Issue:</strong> The model may have low recall (miss actual failures) due to class imbalance.</p>`;
                html += `<p><strong>Solution:</strong> Choose a method to handle class imbalance:</p>`;
                html += '</div>';
                
                html += '<div class="sampling-options">';
                html += `<div class="sampling-option" data-method="none">
                    <h5>No Handling</h5>
                    <p>Train with original data distribution</p>
                    <small>Fast but may have poor recall</small>
                </div>`;
                html += `<div class="sampling-option" data-method="smote">
                    <h5>SMOTE Oversampling</h5>
                    <p>Create synthetic failure samples</p>
                    <small>Good for improving recall</small>
                </div>`;
                html += `<div class="sampling-option" data-method="undersampling">
                    <h5>Random Undersampling</h5>
                    <p>Reduce non-failure samples</p>
                    <small>Balanced but may lose information</small>
                </div>`;
                html += `<div class="sampling-option" data-method="class_weight">
                    <h5>Class Weights</h5>
                    <p>Weight failures higher during training</p>
                    <small>Good balance of precision/recall</small>
                </div>`;
                html += '</div>';
                
                html += '<button class="btn btn-success" id="apply-imbalance-handling" style="margin-top: 15px;">Apply Selected Method & Continue</button>';
                
                section.innerHTML = html;
                section.style.display = 'block';
                
                // Add event listeners for sampling options
                document.querySelectorAll('.sampling-option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.sampling-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                    });
                });
                
                // Select class weights by default (recommended)
                document.querySelector('.sampling-option[data-method="class_weight"]').classList.add('selected');
                
                // Add event listener for apply button
                document.getElementById('apply-imbalance-handling').addEventListener('click', () => {
                    this.applyClassImbalanceHandling();
                });
            }

            applyClassImbalanceHandling() {
                const selectedOption = document.querySelector('.sampling-option.selected');
                if (!selectedOption) {
                    alert('Please select a class imbalance handling method');
                    return;
                }
                
                const method = selectedOption.getAttribute('data-method');
                this.showLoading(`Applying ${method}...`);
                
                setTimeout(() => {
                    // Apply class imbalance handling
                    this.pipeline.handleClassImbalance(method);
                    
                    // Split data
                    const splitResult = this.pipeline.splitData();
                    
                    // Preprocess data
                    const processedData = this.pipeline.preprocessData();
                    
                    // Display preprocessing info
                    this.displayPreprocessingInfo(splitResult, processedData, method);
                    
                    // Update step 4 status
                    this.updateStepStatus(4, 'complete');
                    document.getElementById('train-btn').style.display = 'inline-block';
                    
                    this.hideLoading();
                }, 1000);
            }

            displayPreprocessingInfo(splitResult, processedData, imbalanceMethod) {
                const preprocessingContent = document.getElementById('preprocessing-content');
                let html = '';
                
                html += '<h4>Data Split</h4>';
                html += '<div class="data-split-info">';
                html += `<p><strong>Training Set:</strong> ${splitResult.trainSize} records (80%)</p>`;
                html += `<p><strong>Test Set:</strong> ${splitResult.testSize} records (20%)</p>`;
                html += `<p><strong>Class Imbalance Handling:</strong> ${this.getMethodName(imbalanceMethod)}</p>`;
                html += '</div>';
                
                html += '<h4>Preprocessing Steps Applied</h4>';
                html += '<ul>';
                html += '<li>One-hot encoding for categorical features (Product Type)</li>';
                html += '<li>Min-max normalization for numeric features</li>';
                html += '<li>Training/test split before preprocessing to avoid data leakage</li>';
                html += `<li>Class imbalance handling: ${this.getMethodName(imbalanceMethod)}</li>`;
                html += '</ul>';
                
                preprocessingContent.innerHTML = html;
                
                // Show preprocessed data preview
                this.displayPreprocessedPreview(processedData.processedData.X_train_processed.slice(0, 10));
            }

            getMethodName(method) {
                const names = {
                    'none': 'No Handling',
                    'smote': 'SMOTE Oversampling',
                    'undersampling': 'Random Undersampling',
                    'class_weight': 'Class Weighting'
                };
                return names[method] || method;
            }

            evaluateModel() {
                this.showLoading('Evaluating model performance...');
                
                // Switch to evaluation tab
                this.switchTab('evaluation');
                
                setTimeout(() => {
                    const metrics = this.pipeline.evaluateModel(this.pipeline.predictionThreshold);
                    
                    // Display evaluation results
                    this.displayEvaluationResults(metrics);
                    
                    // Display ROC curve
                    this.displayROCCurve();
                    
                    // Display feature importance
                    this.displayFeatureImportance();
                    
                    // Update UI with model metrics
                    this.updateModelMetrics(metrics);
                    
                    // Update step 6 status
                    this.updateStepStatus(6, 'complete');
                    document.getElementById('prediction-ready-btn').style.display = 'inline-block';
                    
                    this.hideLoading();
                }, 800);
            }

            displayROCCurve() {
                const rocData = this.pipeline.rocCurve;
                const ctx = document.getElementById('roc-curve').getContext('2d');
                
                // Create ROC curve chart
                this.rocChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `ROC Curve (AUC = ${rocData.auc.toFixed(3)})`,
                            data: rocData.fpr.map((fpr, index) => ({
                                x: fpr,
                                y: rocData.tpr[index]
                            })),
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }, {
                            label: 'Random Classifier',
                            data: [{x: 0, y: 0}, {x: 1, y: 1}],
                            borderColor: '#95a5a6',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'False Positive Rate'
                                },
                                min: 0,
                                max: 1
                            },
                            y: {
                                type: 'linear',
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'True Positive Rate (Recall)'
                                },
                                min: 0,
                                max: 1
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const pointIndex = context.dataIndex;
                                        const threshold = rocData.thresholds[pointIndex];
                                        return `Threshold: ${threshold.toFixed(2)}, FPR: ${context.parsed.x.toFixed(3)}, TPR: ${context.parsed.y.toFixed(3)}`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Show ROC curve section
                document.getElementById('roc-curve-section').style.display = 'block';
                
                // Add threshold slider event listener
                document.getElementById('threshold-slider').addEventListener('input', (e) => {
                    const threshold = parseFloat(e.target.value);
                    document.getElementById('threshold-value').textContent = threshold.toFixed(2);
                    
                    // Re-evaluate model with new threshold
                    const newMetrics = this.pipeline.evaluateModel(threshold);
                    this.updateModelMetrics(newMetrics);
                });
            }

            displayFeatureImportance() {
                const importance = this.pipeline.featureImportance;
                const featureNames = ['Type_L', 'Type_M', 'Type_H', 'AirTemp', 'ProcessTemp', 'RotationalSpeed', 'Torque', 'ToolWear'];
                
                const ctx = document.getElementById('feature-importance-chart').getContext('2d');
                
                this.featureImportanceChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: featureNames,
                        datasets: [{
                            label: 'Feature Importance (%)',
                            data: importance,
                            backgroundColor: 'rgba(52, 152, 219, 0.7)',
                            borderColor: 'rgb(52, 152, 219)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        scales: {
                            x: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Importance (%)'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Importance: ${context.parsed.x.toFixed(1)}%`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Show feature importance section
                document.getElementById('feature-importance-section').style.display = 'block';
            }

            // ... rest of the methods remain the same
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new UIController();
        });
    </script>
</body>
</html>
